import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { VRButton } from 'three/examples/jsm/webxr/VRButton.js';
import gsap from 'gsap';

/**
 * Base
 */

// Canvas
const canvas = document.querySelector('canvas.webgl');

// Scene
const scene = new THREE.Scene();

/**
 * Loaders
 */
// Texture loader
const textureLoader = new THREE.TextureLoader();
const cubeTextureLoader = new THREE.CubeTextureLoader();

/**
 * Environment map
 */
// LDR cube texture
const environmentMap = cubeTextureLoader.load([
    '3/px.png',
    '3/nx.png',
    '3/py.png',
    '3/ny.png',
    '3/pz.png',
    '3/nz.png',
]);

scene.background = environmentMap;

// Draco loader
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('draco/');

// GLTF loader
const gltfLoader = new GLTFLoader();
gltfLoader.setDRACOLoader(dracoLoader);

/**
 * Texture
 */

const bakedTexture = textureLoader.load('baked.jpg');
bakedTexture.flipY = false;
bakedTexture.colorSpace = THREE.SRGBColorSpace;

const bakedTextureCloth1 = textureLoader.load('cloth1.jpg');
bakedTextureCloth1.flipY = false;
bakedTextureCloth1.colorSpace = THREE.SRGBColorSpace;

const bakedTextureCloth2 = textureLoader.load('cloth2.jpg');
bakedTextureCloth2.flipY = false;
bakedTextureCloth2.colorSpace = THREE.SRGBColorSpace;

const bakedTextureCloth3 = textureLoader.load('cloth3.jpg');
bakedTextureCloth3.flipY = false;
bakedTextureCloth3.colorSpace = THREE.SRGBColorSpace;

const billboardTexture = textureLoader.load('Asset1.png');
billboardTexture.flipY = false;
billboardTexture.colorSpace = THREE.SRGBColorSpace;

const billboardTexture2 = textureLoader.load('Asset2.png');
billboardTexture2.flipY = false;
billboardTexture2.colorSpace = THREE.SRGBColorSpace;

const billboardTexture3 = textureLoader.load('Asset3.png');
billboardTexture3.flipY = false;
billboardTexture3.colorSpace = THREE.SRGBColorSpace;

const billboardTextureW = textureLoader.load('Asset4.png');
billboardTextureW.flipY = false;
billboardTextureW.colorSpace = THREE.SRGBColorSpace;

/**
 * Materials
 */
const bakedMaterial = new THREE.MeshBasicMaterial({ map: bakedTexture });
const bakedMaterialCloth1 = new THREE.MeshBasicMaterial({ map: bakedTextureCloth1 });
const bakedMaterialCloth2 = new THREE.MeshBasicMaterial({ map: bakedTextureCloth2 });
const bakedMaterialCloth3 = new THREE.MeshBasicMaterial({ map: bakedTextureCloth3 });
const billboardMaterial1 = new THREE.MeshBasicMaterial({ map: billboardTexture });
const billboardMaterial2 = new THREE.MeshBasicMaterial({ map: billboardTexture2 });
const billboardMaterial3 = new THREE.MeshBasicMaterial({ map: billboardTexture3 });
const billboardMaterialW = new THREE.MeshBasicMaterial({ map: billboardTextureW });

// Emissive light material
const poleLightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffe5 });
const entityLightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffe5 });
const pathLightMaterial = new THREE.MeshBasicMaterial({ color: 0xe5ffff });

/**
 * Model
 */
let mixer, set1Mesh, set2Mesh, set3Mesh;
gltfLoader.load('WORKSHOP.glb', (gltf) => {
    gltf.scene.traverse((child) => {
        if (child.isMesh) {
            child.material = bakedMaterial;
        }
    });

    scene.add(gltf.scene);

    const lightMesh = gltf.scene.children.find((child) => child.name === 'LL1');
    const entityMesh = gltf.scene.children.find((child) => child.name === 'CL');
    const pathMesh = gltf.scene.children.find((child) => child.name === 'PL2');
    const cloth1Mesh = gltf.scene.children.find((child) => child.name === 'CLOTH1');
    const cloth2Mesh = gltf.scene.children.find((child) => child.name === 'CLOTH2');
    const cloth3Mesh = gltf.scene.children.find((child) => child.name === 'CLOTH3');
    set1Mesh = gltf.scene.children.find((child) => child.name === 'SET1');
    set2Mesh = gltf.scene.children.find((child) => child.name === 'SET2');
    set3Mesh = gltf.scene.children.find((child) => child.name === 'SET3');
    billboardMesh1 = gltf.scene.children.find((child) => child.name === 'BILLBOARD1');
    billboardMesh2 = gltf.scene.children.find((child) => child.name === 'BILLBOARD2');
    billboardMesh3 = gltf.scene.children.find((child) => child.name === 'BILLBOARD3');
    billboardMeshW = gltf.scene.children.find((child) => child.name === 'BILLBOARDW');

    if (lightMesh) lightMesh.material = poleLightMaterial;
    if (entityMesh) entityMesh.material = entityLightMaterial;
    if (pathMesh) pathMesh.material = pathLightMaterial;
    if (set1Mesh) set1Mesh.material = bakedMaterialCloth1;
    if (set2Mesh) set2Mesh.material = bakedMaterialCloth2;
    if (set3Mesh) set3Mesh.material = bakedMaterialCloth3;
    if (billboardMesh1) billboardMesh1.material = billboardMaterial1;
    if (billboardMesh2) billboardMesh2.material = billboardMaterial2;
    if (billboardMesh3) billboardMesh3.material = billboardMaterial3;
    if (billboardMeshW) billboardMeshW.material = billboardMaterialW;

    mixer = new THREE.AnimationMixer(gltf.scene);

    // Debug: Log available animations
    console.log('Available animations:', gltf.animations.map((anim) => anim.name));

    const clips = gltf.animations;
    clips.forEach((clip) => {
        const action = mixer.clipAction(clip);
        action.setLoop(THREE.LoopRepeat); // Set the animation to loop
        action.play();
    });

    if (entityMesh) {
        controls.target.set(entityMesh.position.x + 20, entityMesh.position.y, entityMesh.position.z);
    }

    const animateCamera = (x, y, z, target) => {
        gsap.to(camera.position, {
            duration: 1,
            x: x,
            y: y,
            z: z,
            onUpdate: () => {
                controls.target.set(target.x, target.y, target.z);
                controls.update();
            },
        });
    };

    window.addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();
        const arrow = document.getElementById(`arrow-${key.replace('arrow', '')}`);
        if (arrow) {
            arrow.classList.add('pressed');
        }

        switch (event.key) {
            case 'ArrowUp':
                animateVRCamera(-3, 53, 50, { x: set2Mesh.position.x - 10, y: set2Mesh.position.y - 5, z: set2Mesh.position.z });
                break;
            case 'ArrowRight':
                animateVRCamera(9, 37, 55, { x: set1Mesh.position.x - 10, y: set1Mesh.position.y, z: set1Mesh.position.z });
                break;
            case 'ArrowLeft':
                animateVRCamera(10, 35, 55, { x: set3Mesh.position.x + 5, y: set3Mesh.position.y, z: set3Mesh.position.z });
                break;
            case 'ArrowDown':
                animateVRCamera(-70, 70, 148.19, { x: entityMesh.position.x + 20, y: entityMesh.position.y, z: entityMesh.position.z });
                break;
        }
    });

    window.addEventListener('keyup', (event) => {
        const key = event.key.toLowerCase();
        const arrow = document.getElementById(`arrow-${key.replace('arrow', '')}`);
        if (arrow) {
            arrow.classList.remove('pressed');
        }
    });
});

/**
 * Sizes
 */
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight,
};

window.addEventListener('resize', () => {
    // Update sizes
    sizes.width = window.innerWidth;
    sizes.height = window.innerHeight;

    // Update camera
    camera.aspect = sizes.width / sizes.height;
    camera.updateProjectionMatrix();

    // Update renderer
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
});

/**
 * Camera
 */
// Base camera
const camera = new THREE.PerspectiveCamera(45, sizes.width / sizes.height, 0.1, 1000);
camera.position.x = -70;
camera.position.y = 70;
camera.position.z = 148.19;
scene.add(camera);

// Controls
const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;

/**
 * Renderer
 */
const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
});
renderer.setSize(sizes.width, sizes.height);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 4));
renderer.xr.enabled = true; // Enable WebXR on the renderer

document.body.appendChild(VRButton.createButton(renderer)); // Add the VRButton to the document

// Custom button to exit VR
const exitVRButton = document.createElement('button');
exitVRButton.className = 'exit-vr-button';
exitVRButton.innerText = 'Exit VR';
exitVRButton.style.display = 'none'; // Hide the button initially

exitVRButton.onclick = () => {
    if (renderer.xr.isPresenting) {
        renderer.xr.getSession().end();
    }
};

document.body.appendChild(exitVRButton);

// Show the exit button when entering VR
renderer.xr.addEventListener('sessionstart', () => {
    exitVRButton.style.display = 'block';
});

// Hide the exit button when exiting VR
renderer.xr.addEventListener('sessionend', () => {
    exitVRButton.style.display = 'none';
});

/**
 * Animate
 */
const clock = new THREE.Clock();

const tick = () => {
    const elapsedTime = clock.getElapsedTime();

    // Update controls
    controls.update();

    // Update mixer if initialized
    if (mixer) {
        mixer.update(clock.getDelta());
    }

    // Render
    renderer.render(scene, camera);

    // Call tick again on the next frame
    renderer.setAnimationLoop(tick); // Use setAnimationLoop for VR compatibility
};

tick();

// Helper function to apply animations to VR camera
const animateVRCamera = (x, y, z, target) => {
    gsap.to(camera.position, {
        duration: 1,
        x: x,
        y: y,
        z: z,
        onUpdate: () => {
            controls.target.set(target.x, target.y, target.z);
            controls.update();
        },
    });
};
